import random
import numpy as np
from deap import base, creator, tools, algorithms

# Define the optimization problem (Burma14)
def burma14_eval(individual):
    # Define the objective function (to be minimized)
    objective = sum(individual)
    return (objective,)

# Define the optimization problem boundaries
BOUND_LOW, BOUND_UP = 0, 1
NUM_VARIABLES = 14

# Define the genetic algorithm parameters
POPULATION_SIZE = 50
GENERATIONS = 100
CROSSOVER_PROBABILITY = 0.8
MUTATION_PROBABILITY = 0.2

# Define the type of individuals and fitness (objective) function
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Create a toolbox for the genetic algorithm
toolbox = base.Toolbox()

# Register the individual generator
toolbox.register("attr_bool", random.randint, BOUND_LOW, BOUND_UP)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_bool, n=NUM_VARIABLES)

# Register the population generator
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# Register the evaluation function
toolbox.register("evaluate", burma14_eval)

# Register the genetic operators
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)

# Create the initial population
population = toolbox.population(n=POPULATION_SIZE)

# Evaluate the initial population
fitnesses = list(map(toolbox.evaluate, population))
for ind, fit in zip(population, fitnesses):
    ind.fitness.values = fit

# Run the genetic algorithm
for gen in range(1, GENERATIONS + 1):
    offspring = algorithms.varAnd(population, toolbox, cxpb=CROSSOVER_PROBABILITY, mutpb=MUTATION_PROBABILITY)
    fits = toolbox.map(toolbox.evaluate, offspring)
    for ind, fit in zip(offspring, fits):
        ind.fitness.values = fit
    population[:] = toolbox.select(offspring, k=len(population))
    best_ind = tools.selBest(population, k=1)[0]
    print("Generation", gen, "- Best Fitness:", best_ind.fitness.values[0])

# Print the best solution found
print("Best solution found:", best_ind)
